---
title: "ST 558 Project 1"
author: "Thomas Bulick and Eliza Norman"
format: html
editor: visual
---

## Title

```{r}
library(tidyverse)
```

Code for one full dataset should be here, just need to move it into a function now.

```{r}
# I replaced read_delim with read_csv because I think this is the preferred method. didn't see any changes, let me know if you see something is messed up  -EN
data_raw <- read_csv("https://www4.stat.ncsu.edu/~online/datasets/EDU01a.csv")
data_clean <- data_raw |>
  select(Area_name,STCOU,ends_with("D")) |>
  rename(area_name = Area_name) |>
  arrange(area_name) |> 
  pivot_longer(cols = ends_with("D"), 
               names_to = "varcode", 
               values_to = "vals") |>
  ###I think this code is set up to convert 1900s/2000s data correctly? But let me know if it looks wonky!
  
  ## looks good to me! -EN
  mutate(year = ifelse(as.numeric(substr(varcode,8,9))>25,as.numeric(substr(varcode,8,9))+1900,as.numeric(substr(varcode,8,9))+2000),measure=substr(varcode,1,7))

countydata <- data_clean |>
  slice(grep(pattern = ", \\w\\w", area_name))|>
  mutate(state = substr(area_name,nchar(area_name)-1,nchar(area_name)))
class(countydata) <- c("county", class(countydata))

statedata <- data_clean |>
  slice(grep(pattern = ", \\w\\w", area_name,invert=TRUE)) |>
  mutate(division = ifelse(area_name %in% c("CONNECTICUT", "MAINE", "MASSACHUSETTS", "NEW HAMPSHIRE", "RHODE ISLAND", "VERMONT"),"1",
                    ifelse(area_name %in% c("NEW JERSEY","NEW YORK","PENNSYLVANIA"),"2",
                    ifelse(area_name %in% c("ILLINOIS","INDIANA","MICHIGAN","OHIO","WISCONSIN"),"3",
                    ifelse(area_name %in% c("IOWA","KANSAS","MINNESOTA","MISSOURI","NEBRASKA","NORTH DAKOTA","SOUTH DAKOTA"),"4",
                    ifelse(area_name %in% c("DELAWARE","FLORIDA","GEORGIA","MARYLAND","NORTH CAROLINA","SOUTH CAROLINA","VIRGINIA","DISTRICT OF COLUMBIA","WEST VIRGINIA"),"5",
                    ifelse(area_name %in% c("ALABAMA","KENTUCKY","MISSISSIPPI","TENNESSEE"),"6",
                    ifelse(area_name %in% c("ARKANSAS","LOUISIANA","OKLAHOMA","TEXAS"),"7",
                    ifelse(area_name %in% c("ARIZONA","COLORADO","IDAHO","MONTANA","NEVADA","NEW MEXICO","UTAH","WYOMING"),"8",
                    ifelse(area_name %in% c("ALASKA","CALIFORNIA","HAWAII","OREGON","WASHINGTON"),"9","ERROR"
                    ))))))))))      

class(statedata) <- c("state", class(statedata))
```

```{r}
function_for_step_1_2 <- function(result, value){
  longer_data <- result |>
    select(Area_name,STCOU,ends_with("D")) |>
    rename(area_name = Area_name) |>
    arrange(area_name) |> 
    pivot_longer(cols = ends_with("D"), 
                 names_to = "varcode", 
                 values_to = value) 
  return(longer_data)
}
function_for_step_3 <- function(longer_data){
  create_date_columns <- longer_data |>
      mutate(year =
               ifelse(as.numeric(substr(varcode,8,9))>25,
                      as.numeric(substr(varcode,8,9))+1900,
                      as.numeric(substr(varcode,8,9))+2000),
             measure=substr(varcode,1,7))
  return(create_date_columns)
}
function_for_steps4_5_6 <- function(create_date_columns){
  countydata <- create_date_columns |>
    slice(grep(pattern = ", \\w\\w", area_name))|>
    mutate(state =
             substr(area_name,nchar(area_name)-1,nchar(area_name)))
  class(countydata) <- c("county", class(countydata))

  statedata <- create_date_columns |>
    slice(grep(pattern = ", \\w\\w", area_name,invert=TRUE)) |>
    ###Filtering out duplicate DC values###
    filter(area_name != "District of Columbia") |>
    mutate(division = ifelse(area_name %in% c("CONNECTICUT", "MAINE", "MASSACHUSETTS", "NEW HAMPSHIRE", "RHODE ISLAND", "VERMONT"),"1",
                      ifelse(area_name %in% c("NEW JERSEY","NEW YORK","PENNSYLVANIA"),"2",
                      ifelse(area_name %in% c("ILLINOIS","INDIANA","MICHIGAN","OHIO","WISCONSIN"),"3",
                      ifelse(area_name %in% c("IOWA","KANSAS","MINNESOTA","MISSOURI","NEBRASKA","NORTH DAKOTA","SOUTH DAKOTA"),"4",
                      ifelse(area_name %in% c("DELAWARE","FLORIDA","GEORGIA","MARYLAND","NORTH CAROLINA","SOUTH CAROLINA","VIRGINIA",
                                              "DISTRICT OF COLUMBIA","WEST VIRGINIA"),"5",
                      ifelse(area_name %in% c("ALABAMA","KENTUCKY","MISSISSIPPI","TENNESSEE"),"6",
                      ifelse(area_name %in% c("ARKANSAS","LOUISIANA","OKLAHOMA","TEXAS"),"7",
                      ifelse(area_name %in% c("ARIZONA","COLORADO","IDAHO","MONTANA","NEVADA","NEW MEXICO","UTAH","WYOMING"),"8",
                      ifelse(area_name %in% c("ALASKA","CALIFORNIA","HAWAII","OREGON","WASHINGTON"),"9","ERROR"))))))))))
  class(statedata) <- c("state", class(statedata))
  return(list(countydata, statedata))
}

# wrapper function attempt - should produce same results as above -EN
my_wrapper <- function(url, value = "enrollment"){
  # assume URL is in quotes
  result <- read_csv(url) |>
    function_for_step_1_2(value) |>
    function_for_step_3() |>
    function_for_steps4_5_6()
}
result_tibbles <- my_wrapper(url="https://www4.stat.ncsu.edu/~online/datasets/EDU01a.csv")

countyData_Final <- result_tibbles[[1]]
stateData_Final <- result_tibbles[[2]]
```

```{r}
# combine the rows from the 2 given CSV files into separate data frames (for county versus state) within the list "finalCombo"

combine_datasets <- function(results1, results2){
  ###Removed the "as.data.frame()" parts as I don't think we need them (?) and then they remove the state/county classes when transforming the data that way - TB
  combined_county <- dplyr::bind_rows(results1[[1]],results2[[1]])
  combined_state <- dplyr::bind_rows(results1[[2]],results2[[2]])
  return(list(countyData = combined_county, stateData = combined_state))
}
finalCombo <- combine_datasets(results1 = my_wrapper("https://www4.stat.ncsu.edu/~online/datasets/EDU01a.csv"), results2 = my_wrapper("https://www4.stat.ncsu.edu/~online/datasets/EDU01b.csv"))
class(finalCombo[[2]])
```

```{r}
plot.state <- function(df,var_name="enrollment"){
  mean_data <- df |>
    filter(division != "ERROR") |>
    group_by(division,year) |>
    summarize(var_avg = mean(get(var_name)))
  g <- ggplot(mean_data,aes(x=year,y=var_avg,color=division))
  g+geom_line()
}
plot(finalCombo[[2]])

###I think the assignment was saying to choose any state as a default so I put NC, but let me know If I misunderstood! - TB ###
plot.county <- function(df,state_choice="NC",top_bottom="top",n_given=5,var_name="enrollment"){
  mean_data <- df |>
    filter(state == state_choice) |>
    group_by(area_name) |>
    summarize(var_avg = mean(get(var_name))) 
  ###couldn't figure out the ifelse() or if_else() syntax so i used a more traditional if syntax
    if(tolower(top_bottom)=="top"){
      mean_data <- mean_data |> arrange(desc(var_avg))
    }else if(tolower(top_bottom)=="bottom"){
      mean_data <- mean_data |> arrange(var_avg)
    }else{
      return("ERROR, please specify 'top' or 'bottom'")
    }
  mean_data <- mean_data |> slice(1:n_given)
  plot_data <- left_join(mean_data,df)
  ###Prompt seemed a little unclear, but I think for the county data we are supposed to be plotting the actual data values for enrollment per year, with different lines for the top/bottom n specified counties? That should be completed here. - TB
  g <- ggplot(plot_data,aes(x=year,y=get(var_name),color=area_name))
  g+geom_line()
}
plot.county(finalCombo[[1]])

  
  
  
  
  
```














